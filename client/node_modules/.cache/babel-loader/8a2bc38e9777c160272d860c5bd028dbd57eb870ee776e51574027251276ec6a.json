{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HttpProxyMiddleware = void 0;\nconst httpProxy = require(\"http-proxy\");\nconst config_factory_1 = require(\"./config-factory\");\nconst contextMatcher = require(\"./context-matcher\");\nconst handlers = require(\"./_handlers\");\nconst logger_1 = require(\"./logger\");\nconst PathRewriter = require(\"./path-rewriter\");\nconst Router = require(\"./router\");\nclass HttpProxyMiddleware {\n  constructor(context, opts) {\n    this.logger = (0, logger_1.getInstance)();\n    this.wsInternalSubscribed = false;\n    this.serverOnCloseSubscribed = false;\n    // https://github.com/Microsoft/TypeScript/wiki/'this'-in-TypeScript#red-flags-for-this\n    this.middleware = async (req, res, next) => {\n      var _a, _b;\n      if (this.shouldProxy(this.config.context, req)) {\n        try {\n          const activeProxyOptions = await this.prepareProxyRequest(req);\n          this.proxy.web(req, res, activeProxyOptions);\n        } catch (err) {\n          next(err);\n        }\n      } else {\n        next();\n      }\n      /**\n       * Get the server object to subscribe to server events;\n       * 'upgrade' for websocket and 'close' for graceful shutdown\n       *\n       * NOTE:\n       * req.socket: node >= 13\n       * req.connection: node < 13 (Remove this when node 12/13 support is dropped)\n       */\n      const server = (_b = (_a = req.socket) !== null && _a !== void 0 ? _a : req.connection) === null || _b === void 0 ? void 0 : _b.server;\n      if (server && !this.serverOnCloseSubscribed) {\n        server.on('close', () => {\n          this.logger.info('[HPM] server close signal received: closing proxy server');\n          this.proxy.close();\n        });\n        this.serverOnCloseSubscribed = true;\n      }\n      if (this.proxyOptions.ws === true) {\n        // use initial request to access the server object to subscribe to http upgrade event\n        this.catchUpgradeRequest(server);\n      }\n    };\n    this.catchUpgradeRequest = server => {\n      if (!this.wsInternalSubscribed) {\n        server.on('upgrade', this.handleUpgrade);\n        // prevent duplicate upgrade handling;\n        // in case external upgrade is also configured\n        this.wsInternalSubscribed = true;\n      }\n    };\n    this.handleUpgrade = async (req, socket, head) => {\n      if (this.shouldProxy(this.config.context, req)) {\n        const activeProxyOptions = await this.prepareProxyRequest(req);\n        this.proxy.ws(req, socket, head, activeProxyOptions);\n        this.logger.info('[HPM] Upgrading to WebSocket');\n      }\n    };\n    /**\n     * Determine whether request should be proxied.\n     *\n     * @private\n     * @param  {String} context [description]\n     * @param  {Object} req     [description]\n     * @return {Boolean}\n     */\n    this.shouldProxy = (context, req) => {\n      const path = req.originalUrl || req.url;\n      return contextMatcher.match(context, path, req);\n    };\n    /**\n     * Apply option.router and option.pathRewrite\n     * Order matters:\n     *    Router uses original path for routing;\n     *    NOT the modified path, after it has been rewritten by pathRewrite\n     * @param {Object} req\n     * @return {Object} proxy options\n     */\n    this.prepareProxyRequest = async req => {\n      // https://github.com/chimurai/http-proxy-middleware/issues/17\n      // https://github.com/chimurai/http-proxy-middleware/issues/94\n      req.url = req.originalUrl || req.url;\n      // store uri before it gets rewritten for logging\n      const originalPath = req.url;\n      const newProxyOptions = Object.assign({}, this.proxyOptions);\n      // Apply in order:\n      // 1. option.router\n      // 2. option.pathRewrite\n      await this.applyRouter(req, newProxyOptions);\n      await this.applyPathRewrite(req, this.pathRewriter);\n      // debug logging for both http(s) and websockets\n      if (this.proxyOptions.logLevel === 'debug') {\n        const arrow = (0, logger_1.getArrow)(originalPath, req.url, this.proxyOptions.target, newProxyOptions.target);\n        this.logger.debug('[HPM] %s %s %s %s', req.method, originalPath, arrow, newProxyOptions.target);\n      }\n      return newProxyOptions;\n    };\n    // Modify option.target when router present.\n    this.applyRouter = async (req, options) => {\n      let newTarget;\n      if (options.router) {\n        newTarget = await Router.getTarget(req, options);\n        if (newTarget) {\n          this.logger.debug('[HPM] Router new target: %s -> \"%s\"', options.target, newTarget);\n          options.target = newTarget;\n        }\n      }\n    };\n    // rewrite path\n    this.applyPathRewrite = async (req, pathRewriter) => {\n      if (pathRewriter) {\n        const path = await pathRewriter(req.url, req);\n        if (typeof path === 'string') {\n          req.url = path;\n        } else {\n          this.logger.info('[HPM] pathRewrite: No rewritten path found. (%s)', req.url);\n        }\n      }\n    };\n    this.logError = (err, req, res, target) => {\n      var _a;\n      const hostname = ((_a = req.headers) === null || _a === void 0 ? void 0 : _a.host) || req.hostname || req.host; // (websocket) || (node0.10 || node 4/5)\n      const requestHref = `${hostname}${req.url}`;\n      const targetHref = `${target === null || target === void 0 ? void 0 : target.href}`; // target is undefined when websocket errors\n      const errorMessage = '[HPM] Error occurred while proxying request %s to %s [%s] (%s)';\n      const errReference = 'https://nodejs.org/api/errors.html#errors_common_system_errors'; // link to Node Common Systems Errors page\n      this.logger.error(errorMessage, requestHref, targetHref, err.code || err, errReference);\n    };\n    this.config = (0, config_factory_1.createConfig)(context, opts);\n    this.proxyOptions = this.config.options;\n    // create proxy\n    this.proxy = httpProxy.createProxyServer({});\n    this.logger.info(`[HPM] Proxy created: ${this.config.context}  -> ${this.proxyOptions.target}`);\n    this.pathRewriter = PathRewriter.createPathRewriter(this.proxyOptions.pathRewrite); // returns undefined when \"pathRewrite\" is not provided\n    // attach handler to http-proxy events\n    handlers.init(this.proxy, this.proxyOptions);\n    // log errors for debug purpose\n    this.proxy.on('error', this.logError);\n    // https://github.com/chimurai/http-proxy-middleware/issues/19\n    // expose function to upgrade externally\n    this.middleware.upgrade = (req, socket, head) => {\n      if (!this.wsInternalSubscribed) {\n        this.handleUpgrade(req, socket, head);\n      }\n    };\n  }\n}\nexports.HttpProxyMiddleware = HttpProxyMiddleware;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}