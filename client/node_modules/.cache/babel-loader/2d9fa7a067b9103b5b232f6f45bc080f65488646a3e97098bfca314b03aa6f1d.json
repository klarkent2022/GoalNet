{"ast":null,"code":"'use strict';\n\nconst fill = require('fill-range');\nconst stringify = require('./stringify');\nconst utils = require('./utils');\nconst append = function () {\n  let queue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  let stash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  let enclose = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let result = [];\n  queue = [].concat(queue);\n  stash = [].concat(stash);\n  if (!stash.length) return queue;\n  if (!queue.length) {\n    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;\n  }\n  for (let item of queue) {\n    if (Array.isArray(item)) {\n      for (let value of item) {\n        result.push(append(value, stash, enclose));\n      }\n    } else {\n      for (let ele of stash) {\n        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;\n        result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);\n      }\n    }\n  }\n  return utils.flatten(result);\n};\nconst expand = function (ast) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;\n  let walk = function (node) {\n    let parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    node.queue = [];\n    let p = parent;\n    let q = parent.queue;\n    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n      p = p.parent;\n      q = p.queue;\n    }\n    if (node.invalid || node.dollar) {\n      q.push(append(q.pop(), stringify(node, options)));\n      return;\n    }\n    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n      q.push(append(q.pop(), ['{}']));\n      return;\n    }\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {\n        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n      }\n      let range = fill(...args, options);\n      if (range.length === 0) {\n        range = stringify(node, options);\n      }\n      q.push(append(q.pop(), range));\n      node.nodes = [];\n      return;\n    }\n    let enclose = utils.encloseBrace(node);\n    let queue = node.queue;\n    let block = node;\n    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n      block = block.parent;\n      queue = block.queue;\n    }\n    for (let i = 0; i < node.nodes.length; i++) {\n      let child = node.nodes[i];\n      if (child.type === 'comma' && node.type === 'brace') {\n        if (i === 1) queue.push('');\n        queue.push('');\n        continue;\n      }\n      if (child.type === 'close') {\n        q.push(append(q.pop(), queue, enclose));\n        continue;\n      }\n      if (child.value && child.type !== 'open') {\n        queue.push(append(queue.pop(), child.value));\n        continue;\n      }\n      if (child.nodes) {\n        walk(child, node);\n      }\n    }\n    return queue;\n  };\n  return utils.flatten(walk(ast));\n};\nmodule.exports = expand;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}